{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What's SootUp?","text":"<p>SootUp is a complete overhaul of the good, old static analysis framework Soot.</p> <ul> <li>Transforms JVM bytecode to the intermediate representation Jimple.</li> <li>Provides ClassHierarchy generation</li> <li>CallGraph generation with different algorithms/precisions</li> <li>Inter-procedural data-flow analysis with the IDE/IFDS framework enabled by Heros</li> <li>Applies simple transformations on retrieving a methods Body (see BodyInterceptor)</li> <li>Provides serialization of the Jimple IR.</li> </ul> <p>Important</p> <p>SootUp is not a version update to Soot, it is a completely new implementation written from scratch that aims to be a leaner, modernized and developer friendly successor of Soot. It is not a Drop-In Replacement! The new architecture and API, renders it not trivial to update existing projects that were built on soot. Therefore we recommend using SootUp for greenfield projects. We hope improved type safety and streamlined mechanisms will aide you implementing and debugging your analysis tool. Unfortunately not every feature has been ported - If you miss something feel free to contribute a feature you miss from good old Soot.</p>"},{"location":"#why-sootup","title":"Why SootUp?","text":"<p>Over the 20+ years, SootUps predecessor Soot has evolved into a powerful framework, which is one of the most widely used tools in the static analysis community.  This evolution was guided by the needs of the community and carried out with ad-hoc improvements. As a result, Soot has become a tool that can do a multitude of things, but it is heavy and hard to maintain and comprehend. So there was the need to clean up the codebase e.g. improve the software architecture, remove legacy datastructures that weren't in the Java Runtime at the time of Soots creation, enforce validation to have a sane state, removing the necessity of arcane knowledge, document it more and more - to make Soot future prove. So we introduced Design changes in SootUp, which aim to address Soot's shortcomings. The goal is a lighter library that can easily be understood and maintained to be included in other projects.</p>"},{"location":"#supporters","title":"Supporters","text":"<p>The development of SootUp is financed by generous support from the German Research Foundation (DFG) and the Heinz Nixdorf Institute (HNI).</p> <p>Become a sponsor!</p>"},{"location":"advanced-topics/","title":"Functionalities and Utilities","text":""},{"location":"advanced-topics/#locallivenessanalyser","title":"LocalLivenessAnalyser","text":"<p>LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given <code>Stmt</code>.</p> <p>Example:</p> <p></p> <p>The live local variables before and after each <code>Stmt</code> will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods <code>getLiveLocalsBeforeStmt</code> and <code>getLiveLocalsAfterStmt</code>.</p>"},{"location":"advanced-topics/#dominancefinder","title":"DominanceFinder","text":"<p>DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block.</p> <p>Example:  </p> <p>After generating an instance of DominanceFinder for a <code>BlockGraph</code>, we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods<code>getImmediateDominator</code>and<code>getDominanceFrontiers</code>.</p>"},{"location":"announce/","title":"Announcements","text":""},{"location":"announce/#release-announcement","title":"Release Announcement","text":"<p>We would like to announce Soot\u2019s successor, SootUp. </p> <p>Over more than 20 years, Soot has become one of the world\u2019s most popular academic tool for Java and Android analysis and instrumentation. We thank all of you who have used and contributed to it over the years! It was your feedback and your contributions that helped it grow into such a versatile tool!</p> <p>However, over the years, the requirements for Soot have changed a lot, and given its original architecture, it was no longer quite up to the task. Soot was originally developed for ahead-of-time code transformation, particularly optimization, which has become very uncommon in Java. Current use cases center much more around powerful program analyses and program-understanding tasks.</p> <p>Today we are officially releasing SootUp, a new version of Soot with a completely overhauled architecture. With SootUp, we aim to keep the best things about Soot, yet overcome a lot of its drawbacks. We very much restructured Soot, particularly abolishing the heavy use of singletons. Soot now has a concept of views; each view corresponds to some version or variant of an analyzed program, and multiple views can be kept in memory at the same time. This sets the foundation, for instance, for differential or incremental program analyses.</p> <p>SootUp is a library that can easily be included in other projects, leaving those projects in control. For those who intend to use it as a framework, with inversion of control, SootUp provides additional templates that help you and novices to get started more easily. The Jimple IR has been slightly simplified, and has been made immutable by default such that internally SootUp can make use of caching where desired. Where required, Jimple transformations are still allowed, but in a systematic manner, for instance assuring that analyses depending on the transformed code are notified about its changes.</p> <p>Below is an overview of what\u2019s new. </p> <ul> <li>Library by default, framework as an option</li> <li>Modular Architecture, no more singletons</li> <li>New source code frontend</li> <li>Immutable Jimple IR</li> <li>Greatly increased testability and test coverage</li> </ul> <p>SootUp is not a drop-in replacement for Soot! Due to its completely new architecture and API it is essentially an almost complete rewrite. For a while, Soot and SootUp will coexist, as many existing tools depend on Soot, yet our maintenance efforts will henceforth be focused on SootUp, not Soot, and on extending SootUp with those capabilities that people still find missing. For now, we recommend using SootUp for greenfield projects.</p> <p>For more details, check out * The SootUp home page: https://soot-oss.github.io/SootUp/, and  * The SootUp repository: https://github.com/soot-oss/SootUp/</p> <p>We are very much looking forward to your feedback and feature requests. To this end, best create appropriate issues in the repository.</p> <p>This major upgrade of Soot was made possible by generous competitive funding by the DFG, within the project \u201cFuture-proofing the Soot Framework for Program Analysis and Transformation (FutureSoot)\u201d. It was funded in the DFG\u2019s program on Research Software Sustainability.</p>"},{"location":"bodyinterceptors/","title":"Body Interceptors","text":"<p>Soot Equivalent</p> <p>BodyTransformer</p> <p>BodyInterceptors are applied to each <code>Body</code> by default to improve or even normalize the raw Jimple that was produced in an earlier step e.g.  by eliminating unreachable code (<code>UnreachableCodeEliminator</code>), standardizing names of locals (<code>LocalNameStandardizer</code>), or removing empty switch statements (<code>EmptySwitchEliminator</code>) etc. </p> <p>Below, we show how these BodyInterceptors work for the users who are interested in their internal workings.</p>"},{"location":"bodyinterceptors/#localsplitter","title":"LocalSplitter","text":"<p>LocalSplitter is a<code>BodyInterceptor</code>that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables.</p> <p>Example 1: </p> <p></p> <p>As shown in the example above, the local variable<code>l1</code>is defined twice. It can be split up into two new local variables: <code>l1#1</code> and <code>l1#2</code> because the both definitions are independent of each other. </p> <p>Look for foldable navigation and tabs for showing old vs new</p> <p>Example 2:</p> <p></p> <p>In the second example, the local variable<code>l2</code>is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure.</p>"},{"location":"bodyinterceptors/#localpacker","title":"LocalPacker","text":"<p>LocalPacker is a<code>BodyInterceptor</code>that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker.</p> <p>Example:</p> <p></p> <p>In the given example above, the local variables<code>l1</code>,<code>l3</code>are summarized to be one local variable<code>l1</code>, because they have the same type without interference with each other. Likewise, the local variables<code>l2</code>,<code>l4</code>and<code>l5</code>are summarized to be another local variable<code>l2</code>. Although the local variable<code>l0</code>doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type.</p>"},{"location":"bodyinterceptors/#traptightener","title":"TrapTightener","text":"<p>WIP - currently not available!</p> <p>TrapTightener is a<code>BodyInterceptor</code>that shrinks the protected area covered by each Trap in a Body. </p> <p>Example:</p> <p></p> <p>We assume in the example above that only the<code>Stmt</code>:<code>l2 := 2</code>might throw an exception caught by the<code>Trap</code>which is labeled with<code>label3</code>. In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three<code>Stmts</code>:<code>l1 := 1; l2 := 2; l2 := 3</code>. But an exception could only arise at the<code>Stmt</code>:<code>l2 := 2</code>. After the implementation of TrapTightener, we will get a contractible protected area which contains only the<code>Stmt</code>that might throw an exception, namely the<code>Stmt</code>:<code>l2 := 2</code>.</p>"},{"location":"bodyinterceptors/#emptyswitcheliminator","title":"EmptySwitchEliminator","text":"<p>EmptySwitchEliminator is a<code>BodyInterceptor</code>that removes empty switch statements which contain only the default case.</p> <p>Example: </p> <p></p> <p>As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a<code>GotoStmt</code>to the default case.</p>"},{"location":"bodyinterceptors/#unreachablecodeeliminator","title":"UnreachableCodeEliminator","text":"<p>UnreachableCodeEliminator is a<code>BodyInterceptor</code>that removes all unreachable statements.</p> <p>Example: </p> <p></p> <p>Obviously, the code segment<code>l2 = 2; l3 = 3;</code>is unreachable. It will be removed after running the UreachableCodeEliminator.</p>"},{"location":"bodyinterceptors/#copypropagator","title":"CopyPropagator","text":"<p>CopyPropagator is a<code>BodyInterceptor</code>that supports the global copy propagation and constant propagation. </p> <p>Example for global copy propagation:</p> <p></p> <p>Consider a code segment in the following form: </p> <pre><code>a = b;\n...\nc = use(a); // a, b, c are local variables\n</code></pre> <p>According to the copy propagation's definition, the statement<code>c = use(a)</code>can be replaced with<code>c = use(b)</code>iff both conditions are met: </p> <ul> <li><code>a</code>is defined only one time on all the paths from<code>a = b</code>to<code>c = use(a)</code>.</li> <li>There are no definitions of<code>b</code>on any path from<code>a = b</code>to<code>c = use(a)</code>.</li> </ul> <p>In the example for global copy propagation, the first used<code>l1</code>is replaced with<code>l0</code>, but the second used<code>l1</code>cannot be replaced with<code>l3</code>, because the second condition is not satisfied.</p> <p>Example for constant propagation:</p> <p></p> <p>Constant propagation is similar to copy propagation. Consider a code segment in the following form:</p> <pre><code>a = const;\n...\nb = use(a); // a, b are local variables, const is a constant\n</code></pre> <p>After perfoming the constant propagation, the statement<code>b = use(a)</code>can be replaced with<code>b = use(const)</code>iff<code>a</code>is not redefined on any of the paths from<code>a = const</code>to<code>b = use(a)</code>.</p> <p>Therefore, the first used<code>l1</code>in the second example can be replaced with the constant<code>1</code>, but the second used<code>l1</code>cannot be replaced with the constant<code>2</code>, because<code>l1</code>is redefined on the path from<code>l1 = 2</code>to<code>l4 = use(l1)</code>.  However, it can be replaced with local variable<code>l2</code>, because the both conditions of copy propagation are met. </p>"},{"location":"bodyinterceptors/#localnamestandardizer","title":"LocalNameStandardizer","text":"<p>LocalNameStandardizer is a<code>BodyInterceptor</code>that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order.  Each assigned name consists of two parts:</p> <ul> <li>A letter to imply the local variable's type</li> <li>A digit to imply the local variable's order</li> </ul> <p>The following table shows the letter corresponding to each type:</p> Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r"},{"location":"bodyinterceptors/#staticsingleassignmentformer","title":"StaticSingleAssignmentFormer","text":"<p>StaticSingleAssignmentFormer is a<code>BodyInterceptor</code>that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use.</p> <p>Example:</p> <p></p> <p></p> <p>In the given example, the StaticSingleAssignmentFormer assigns each<code>IdentityStmt</code>and<code>AssignStmt</code>to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a<code>PhiStmt</code>in the front of the join block to merge all most recently defined local variables and assign them a new local variable.</p>"},{"location":"call-graph-construction/","title":"Call Graph Construction","text":"<p>A call graph shows the method calling relationship of a program. It is a directed graph, whose nodes represent different methods, and edges represent caller -&gt; callee relationship.</p> <p>SootUp contains several call graph construction algorithms. Below, we show how you can use each of these.</p>"},{"location":"call-graph-construction/#creating-the-type-hierarchy","title":"Creating the Type Hierarchy","text":"<p>All the call graph construction algorithms require the view to access the type hierarchy for resolving method calls based of sub typing relationship. Below, we show how to create a type hierarchy:</p> SootUpSoot <pre><code>List&lt;AnalysisInputLocation&gt; inputLocations = new ArrayList();\ninputLocations.add(new JavaClassPathAnalysisInputLocation(\"src/test/resources/Callgraph/binary\"));\ninputLocations.add(new DefaultRTJarAnalysisInputLocation());\n\nJavaView view = new JavaView(inputLocations);\n</code></pre> <pre><code>String targetTestClassName = target.exercise1.Hierarchy.class.getName();\nG.reset();\nString userdir = System.getProperty(\"user.dir\");\nString sootCp = userdir + File.separator + \"target\" + File.separator + \"test-classes\"+ File.pathSeparator + \"lib\"+File.separator+\"rt.jar\";\nOptions.v().set_whole_program(true);\nOptions.v().set_soot_classpath(sootCp);\nOptions.v().set_no_bodies_for_excluded(true);\nOptions.v().process_dir();\nOptions.v().set_allow_phantom_refs(true);\nOptions.v().setPhaseOption(\"jb\", \"use-original-names:true\");\nOptions.v().set_prepend_classpath(false);\nSootClass c = Scene.v().forceResolve(targetTestClassName, SootClass.BODIES);\nif (c != null)\n    c.setApplicationClass();\nScene.v().loadNecessaryClasses();\n\nHierarchy hierarchy = new Hierarchy();\n</code></pre>"},{"location":"call-graph-construction/#defining-an-entry-method","title":"Defining an Entry Method","text":"<p>All the call graph construction algorithms require an entry method to start with. In java application, you usually define the main method. However, it is possible to define arbitrary entry methods depending on your needs. Below, we show how to define such an entry method:</p> SootUpSoot <pre><code>JavaClassType classTypeA = view.getIdentifierFactory().getClassType(\"A\");\n\nMethodSignature entryMethodSignature =\n    view.getIdentifierFactory()\n        .getMethodSignature(\n            classTypeA,\n            JavaIdentifierFactory.getInstance()\n                .getMethodSubSignature(\n                    \"calc\", VoidType.getInstance(), Collections.singletonList(classTypeA)));    \n</code></pre> <pre><code>SootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");     \n</code></pre>"},{"location":"call-graph-construction/#class-hierarchy-analysis","title":"Class Hierarchy Analysis","text":"<p>Class Hierarchy Analysis (CHA) algorithm is the most sound call graph construction algorithm available in SootUp. It soundly includes all implementers of an interface, when resolving a method call on an interface. You can construct a call graph with CHA as follows:</p> SootUpSoot <pre><code>CallGraphAlgorithm cha = \n        new ClassHierarchyAnalysisAlgorithm(view);\n\nCallGraph cg = \n        cha.initialize(Collections.singletonList(entryMethodSignature));\n\nSystem.out.println(cg);\n</code></pre> <pre><code>CHATransformer.v().transform();\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");\nCallGraph cg = Scene.v().getCallGraph();\nIterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(src));\nwhile (targets.hasNext()) {\n    SootMethod tgt = (SootMethod)targets.next();\n    System.out.println(src + \" may call \" + tgt);\n    }\n</code></pre>"},{"location":"call-graph-construction/#rapid-type-analysis","title":"Rapid Type Analysis","text":"<p>Rapid Type Analysis (RTA) algorithm constructs a rather precise version of the call graph that the CHA constructs. It refines CHA by considering only the instantiated implementers of an interface, when resolving a method call on an interface. You can construct a call graph with RTA as follows:</p> SootUpSoot <pre><code>CallGraphAlgorithm rta = \n        new RapidTypeAnalysisAlgorithm(view);\n\nCallGraph cg = \n        rta.initialize(Collections.singletonList(entryMethodSignature));\n\nSystem.out.println(cg);\n</code></pre> <pre><code>Transform sparkConfig = new Transform(\"cg.spark\", null);\nPhaseOptions.v().setPhaseOption(sparkConfig, \"enabled:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"rta:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"on-fly-cg:false\");\nMap phaseOptions = PhaseOptions.v().getPhaseOptions(sparkConfig);\nSparkTransformer.v().transform(sparkConfig.getPhaseName(), phaseOptions);\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");\nCallGraph cg = Scene.v().getCallGraph();\nIterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(src));\nwhile (targets.hasNext()) {\n    SootMethod tgt = (SootMethod)targets.next();\n    System.out.println(src + \" may call \" + tgt);\n}  \n</code></pre>"},{"location":"call-graph-construction/#variable-type-analysis","title":"Variable Type Analysis","text":"<p>Variable Type Analysis (VTA) algorithm further refines the call graph that the RTA constructs. It refines RTA by considering only the assigned instantiations of the implementers of an interface, when resolving a method call on an interface. When considering assignments, we usually need to consider pointer (points-to) relationship.</p> <p>Info</p> <p>VTA algorithm was implemented using the Spark pointer analysis framework. A reimplementation of Spark in SootUp is currently under development.</p> <p>Spark requires an initial call graph to begin with. You can use one of the call graphs that we have constructed above. You can construct a call graph with VTA as follows:</p> SootUpSoot <pre><code>Spark spark = new Spark.Builder(view, callGraph).vta(true).build();\nspark.analyze();\nCallGraph vtaCAllGraph = spark.getCallGraph();\n</code></pre> <pre><code>Transform sparkConfig = new Transform(\"cg.spark\", null);\nPhaseOptions.v().setPhaseOption(sparkConfig, \"enabled:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"vta:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"on-fly-cg:false\");\nMap phaseOptions = PhaseOptions.v().getPhaseOptions(sparkConfig);\nSparkTransformer.v().transform(sparkConfig.getPhaseName(), phaseOptions);\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");\nCallGraph cg = Scene.v().getCallGraph();\nIterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(src));\nwhile (targets.hasNext()) {\n    SootMethod tgt = (SootMethod)targets.next();\n    System.out.println(src + \" may call \" + tgt);\n}    \n</code></pre>"},{"location":"docguide/","title":"Docguide","text":""},{"location":"docguide/#general","title":"General","text":""},{"location":"docguide/#mkdocsextensions","title":"MkDocsExtensions","text":""},{"location":"docguide/#tooltip","title":"Tooltip","text":"<p>Hover me</p>"},{"location":"docguide/#example-file-inclusion","title":"Example File inclusion","text":"<p>this enables that tutorial code can be tested and will fail if its not up to date anymore :)</p> <pre><code>package sootup.examples.basicSetup;\n\nimport static org.junit.Assert.assertTrue;\n\nimport categories.Java8Test;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport sootup.core.inputlocation.AnalysisInputLocation;\nimport sootup.core.jimple.common.expr.JVirtualInvokeExpr;\nimport sootup.core.jimple.common.stmt.JInvokeStmt;\nimport sootup.core.model.SootClass;\nimport sootup.core.model.SootMethod;\nimport sootup.core.signatures.MethodSignature;\nimport sootup.core.types.ClassType;\nimport sootup.core.views.View;\nimport sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation;\nimport sootup.java.core.language.JavaJimple;\nimport sootup.java.core.views.JavaView;\n\n/** This example illustrates how to create and use a new Soot Project. */\n@Category(Java8Test.class)\npublic class BasicSetup {\n\n  @Test\n  public void createByteCodeProject() {\n    // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded\n    // from the directory\n    Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\");\n    AnalysisInputLocation inputLocation = PathBasedAnalysisInputLocation.create(pathToBinary, null);\n\n    // Create a view for project, which allows us to retrieve classes\n    View view = new JavaView(inputLocation);\n\n    // Create a signature for the class we want to analyze\n    ClassType classType = view.getIdentifierFactory().getClassType(\"HelloWorld\");\n\n    // Create a signature for the method we want to analyze\n    MethodSignature methodSignature =\n        view.getIdentifierFactory()\n            .getMethodSignature(\n                classType, \"main\", \"void\", Collections.singletonList(\"java.lang.String[]\"));\n\n    // Assert that class is present\n    assertTrue(view.getClass(classType).isPresent());\n\n    // Retrieve class\n    SootClass sootClass = view.getClass(classType).get();\n\n    // Retrieve method\n    view.getMethod(methodSignature);\n\n    // Alternatively:\n    assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent());\n    SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get();\n\n    // Read jimple code of method\n    System.out.println(sootMethod.getBody());\n\n    // Assert that Hello world print is present\n    assertTrue(\n        sootMethod.getBody().getStmts().stream()\n            .anyMatch(\n                stmt -&gt;\n                    stmt instanceof JInvokeStmt\n                        &amp;&amp; stmt.getInvokeExpr() instanceof JVirtualInvokeExpr\n                        &amp;&amp; stmt.getInvokeExpr()\n                            .getArg(0)\n                            .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\"))));\n  }\n}\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-to-setup-the-soot-dependency-in-maven-gradle","title":"How to setup the soot dependency (in Maven, Gradle)?","text":"<p>See Installation.</p>"},{"location":"faq/#how-to-retreive-a-sootclass-or-sootmethod","title":"How to retreive a SootClass or SootMethod?","text":"<p>See Getting Started.</p>"},{"location":"faq/#is-there-a-github-template-to-quickstart-into-development-with-sootup","title":"Is there a github template to quickstart into development with SootUp?","text":"<p>Not yet.</p>"},{"location":"faq/#error-while-using-the-sourcecodefrontend","title":"Error while using the Sourcecodefrontend","text":"<p>Please make sure to use Java8 to execute. </p>"},{"location":"faq/#exception-provider-jrt-not-found","title":"Exception: Provider \"jrt\" not found","text":"<p><pre><code>java.lang.ExceptionInInitializerError\n    at sootup.java.bytecode.inputlocation.JrtFileSystemAnalysisInputLocationTest.getClassSource(JrtFileSystemAnalysisInputLocationTest.java:28)\n    ...\nCaused by: java.nio.file.ProviderNotFoundException: Provider \"jrt\" not found\n</code></pre> To execute SootUp with JavaModules support please make sure you run the code at least the Java9 Runtime.</p>"},{"location":"faq/#how-to-solve-a-concurrentmodificationexception","title":"How to solve a ConcurrentModificationException?","text":"<p>Copy the Iterator into an intermediate Collection.  <pre><code>final StmtGraph&lt;?&gt; stmtGraph = builder.getStmtGraph();\n    for (Stmt stmt : Lists.newArrayList(stmtGraph)){\n        ...\n    }\n}\n</code></pre></p>"},{"location":"faq/#how-can-i-visualize-a-stmtgraph","title":"How can I visualize a StmtGraph?","text":"<p>There exists a tool, that converts a StmtGraph to the Graphviz Dot Language. <pre><code>DotExporter.buildGraph( stmtgraph );\n</code></pre> or create a convenient link with the exported stmtgraph as HTTP GET Parameter <pre><code>DotExporter.createUrlToWebeditor( stmtgraph );\n</code></pre></p>"},{"location":"faq/#is-there-a-way-to-use-code-exploration-and-syntax-highlighting-features-in-my-ide-for-jimple-files","title":"Is there a way to use code exploration and syntax highlighting features in my IDE for .jimple files?","text":"<p>Try JimpeLsp.</p>"},{"location":"faq/#is-there-a-way-to-use-syntax-highlighting-of-jimple-in-my-paper-thesis","title":"Is there a way to use syntax highlighting of .jimple in my paper, thesis, ...?","text":"<p>Have a look at LspLexer4Pygments.</p>"},{"location":"faq/#how-to-add-an-entry-in-this-list-ie-your-question-is-not-answered-here","title":"How to ... add an entry in this list? i.e. Your question is not answered here?","text":"<p>Feel free to start a Discussion. </p>"},{"location":"getting-started/","title":"General Usage of SootUp","text":"<p>This page walks you through the core data structures, as well as shows how to get started with SootUp.</p>"},{"location":"getting-started/#the-core-datastructures","title":"The core datastructures","text":"<p>Before you get started with the SootUp library, it helps to learn about the following core data structures:</p> <ul> <li> <p><code>Language</code>: represents the programming language of the analyzed code. </p> </li> <li> <p><code>AnalysisInputLocation</code>: points to the target code to be analyzed.</p> </li> </ul> <p>Soot Equivalent</p> <p>It corresponds to the <code>cp</code> option, which specifies the classpath for Soot to find classes to be analyzed.</p> <ul> <li><code>View</code>: presents the code/classes under analysis.</li> </ul> <p>Soot Equivalent</p> <p>It corresponds to the <code>Scene</code> class, but it is not a singleton. So it is possible to instantiate multiple views simultaneously.</p> <ul> <li> <p><code>Scope</code>: defines the scope of the <code>View</code>. By default, the <code>View</code> is created with all code found on the <code>AnalysisInputLocation</code> specified for the <code>Project</code> instance.</p> </li> <li> <p><code>SootClass</code>: represents a class loaded into the <code>View</code>.</p> </li> <li> <p><code>SootMethod</code>: represents a method of a class.</p> </li> <li> <p><code>SootField</code>: represents a field of a class.</p> </li> <li> <p><code>Body</code>: represents a method body in Jimpe.</p> </li> <li> <p><code>StmtGraph</code>: represents the control flow graph of a method body in Jimple statements.</p> </li> </ul>"},{"location":"getting-started/#creating-a-view","title":"Creating a View","text":"<p>You can use bytecode analysis typically when you do not have access to the source code of the target program. Following example shows how to create a view for analyzing Java bytecode.</p> <p>Create a view to analyze Java bytecode</p> <pre><code>AnalysisInputLocation inputLocation = \n        new JavaClassPathAnalysisInputLocation(\"path2Binary\");\n\nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>If you have access to the source code, it is also possible to create a view for analyzing source code. Following example shows how to create view for analyzing Java source code.</p> <p>Experimental</p> <p>The source code frontend is experimental and should only be used for testing purposes. You should compile the code for analysis first and use the bytecode frontend instead.  </p> <p>Create a view to analyze Java source code</p> <pre><code>AnalysisInputLocation inputLocation = \n        new JavaSourcePathAnalysisInputLocation(\"path2Source\");\n\nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>If you have a Jimple file, you can create a view for analyzing jimple code directly. Following example shows how to create a view for analyzing jimple code.</p> <p>Create a project to analyze jimple code</p> <pre><code>Path pathToJimple = Paths.get(\"path2Jimple\");\n\nAnalysisInputLocation inputLocation = \n        new JimpleAnalysisInputLocation(pathToJimple);\n\nJimpleView view = new JimpleView(inputLocation);\n</code></pre> <p>By default, whenever a class is retrieved, it will be permanently stored in a cache. If you do not want retrieved classes to be stored indefinetly, you can instead provide a different <code>CacheProvider</code> to the created view. To for example use an <code>LRUCache</code> instead, which stores at most 50 classes, and always replaces the least recently used class by a newly retrieved one, use the following call:</p> <pre><code>JavaView view = new JavaView(Collections.singletonList(inputLocation), new LRUCacheProvider(50));\n</code></pre>"},{"location":"getting-started/#retrieving-a-class","title":"Retrieving a Class","text":"<p>Each class is identified with a unique signature adhering to Java identifier rules, therefore you first need to specify the class signature (<code>ClassType</code>) as shown below.</p> <p>Let's say the following is the target program that we want to analyze:</p> <p>Target Program</p> <pre><code>package example;\n\npublic class HelloWorld {\n\n  public HelloWorld() {\n\n  }\n\n  public static void main(String[] args) {\n    HelloWorld hw = new HelloWorld();\n    hw.hello();\n  }\n\n  public void hello() {\n\n  }\n\n}\n</code></pre> <p>Then, we could define the <code>ClassType</code> of the <code>HelloWorld</code> class as follows:</p> <p>Defining a ClassType</p> <pre><code>JavaClassType classType = \n        view.getIdentifierFactory().getClassType(\"example.HelloWorld\");\n</code></pre> <p>Once we have a <code>ClassType</code> that identifies the <code>HelloWorld</code> class, we can use it to retrieve the corresponding <code>SootClass</code> object from the <code>view</code> as shown below:</p> <p>Retrieving a SootClass</p> <pre><code>JavaSootClass sootClass = view.getClass(classType).get();\n</code></pre>"},{"location":"getting-started/#retrieving-a-method","title":"Retrieving a Method","text":"<p>Like the classes, methods also have an identifier which we call <code>MethodSignature</code>. For instance, we can define the method signature for identifying the <code>main</code> method of the <code>HelloWorld</code> class as follows:</p> <p>Defining a MethodSignature</p> <pre><code>MethodSignature methodSignature =\n    view\n        .getIdentifierFactory()\n        .getMethodSignature(\n            \"main\", // method name\n            classType,\n            \"void\", // return type\n            Collections.singletonList(\"java.lang.String[]\")); // args\n</code></pre> <p>Once we have a <code>MethodSignature</code> that identifies the <code>main</code> method of the <code>HelloWorld</code> class, we can use it to retrieve the corresponding <code>SootMethod</code> object from the <code>view</code> as shown below:</p> <p>Retrieving a SootMethod from the View</p> <pre><code>Optional&lt;SootMethod&gt; opt = view.getMethod(methodSignature);\n\nif(opt.isPresent()){\n  SootMethod method = opt.get();\n}\n</code></pre> <p>Alternatively, we can also retrieve a <code>SootMethod</code> from <code>SootClass</code> that contains it.</p> <p>Retrieving a SootMethod from a SootClass</p> <pre><code>Optional&lt;JavaSootMethod&gt; opt = sootClass.getMethod(methodSignature.getSubSignature());\n\nif(opt.isPresent()){\n  JavaSootMethod method = opt.get();\n}\n</code></pre>"},{"location":"getting-started/#retrieving-the-control-flow-graph-of-a-method","title":"Retrieving the Control-Flow Graph of a Method","text":"<p>Each <code>SootMethod</code> contains a Control-Flow Graph (CFG) which is represented via the <code>StmtGraph</code>. This structure is usually used for program analysis. You can retrieve the CFG of a <code>SootMethod</code> as follows:</p> <p>Retrieving the CFG of a SootMethod</p> <pre><code>sootMethod.getBody().getStmts();\n</code></pre> <p>Access or Download all of the code used above</p> <p>BasicSetup.java</p>"},{"location":"getting-started/#sootup-vs-soot","title":"SootUp vs Soot","text":"<p>Below we show a comparison of the code so far with the same functionality in sootup.</p> SootUpSoot <pre><code>AnalysisInputLocation&lt;JavaSootClass&gt; inputLocation =\nnew JavaClassPathAnalysisInputLocation(\"path2Binary\");\n\nJavaView view = new JavaView(inputLocation);\n\nJavaClassType classType = \n        view.getIdentifierFactory().getClassType(\"HelloWorld\");\n\nMethodSignature methodSignature =\n    view\n        .getIdentifierFactory()\n        .getMethodSignature(\n            \"main\", classType, \"void\",\n            Collections.singletonList(\"java.lang.String[]\"));\n\nJavaSootClass sootClass = view.getClass(classType).get();\n\nJavaSootMethod sootMethod =  sootClass.getMethod(methodSignature.getSubSignature()).get();\n\nsootMethod.getBody().getStmts();\n</code></pre> <pre><code>G.reset();\nString userdir = System.getProperty(\"user.dir\");\nString sootCp = \n        userdir \n        + File.separator \n        + \"target\" \n        + File.separator \n        + \"test-classes\"\n        + File.pathSeparator + \"lib\"+File.separator+\"rt.jar\";\n\nOptions.v().set_soot_classpath(sootCp);\nOptions.v().set_whole_program(true);\nOptions.v().setPhaseOption(\"cg.cha\", \"on\");\nOptions.v().setPhaseOption(\"cg\", \"all-reachable:true\");\nOptions.v().set_no_bodies_for_excluded(true);\nOptions.v().set_allow_phantom_refs(true);\nOptions.v().setPhaseOption(\"jb\", \"use-original-names:true\");\nOptions.v().set_prepend_classpath(false);\n\nScene.v().addBasicClass(\"java.lang.StringBuilder\");\nSootClass c = \n    Scene.v().forceResolve(targetTestClassName, SootClass.BODIES);\nif (c != null) {\n    c.setApplicationClass();\n}\nScene.v().loadNecessaryClasses();\n\nSootMethod method;\nfor (SootClass c : Scene.v().getApplicationClasses()) {\n    if(c.getName().equals(\"example.HelloWorld\")){\n        for (SootMethod m : c.getMethods()) {\n            if (!m.hasActiveBody()) {\n                continue;\n            }\n            if (m.getName().equals(\"entryPoint\")) {\n                method = m;\n                break;\n            }\n        }\n    }\n}\n\nmethod.getActiveBody().getUnits();\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-the-latest-version-on-the-develop-branch","title":"Using the latest version on the develop branch","text":"<p>visit SootUp on Jitpack.io for configuration options of your build tool.</p>"},{"location":"installation/#using-the-release","title":"Using the release","text":"<p>SootUp is available in maven central, you can include it in your project as follows.</p> <p>Below we only show how you can add the SootUp modules to your project. It is not necessary to add all the modules as dependency.  Depending on your needs you can import only the modules you need. Take a look at the Modules to learn more about which modules you might need.</p>"},{"location":"installation/#maven","title":"Maven","text":"<p>Add the following dependency in the <code>pom.xml</code> file of your project to include all SootUp modules into your project.</p> <pre><code>&lt;repositories&gt;\n &lt;repository&gt;\n  &lt;id&gt;jitpack.io&lt;/id&gt;\n  &lt;url&gt;https://jitpack.io&lt;/url&gt;\n &lt;/repository&gt;\n &lt;repository&gt;\n  &lt;id&gt;/maven.google.com&lt;/id&gt;\n  &lt;url&gt;https://maven.google.com&lt;/url&gt;\n &lt;/repository&gt;\n&lt;/repositories&gt;\n\n&lt;dependencies&gt;\n &lt;dependency&gt;\n   &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n   &lt;artifactId&gt;sootup.core&lt;/artifactId&gt;\n   &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.java.core&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.java.sourcecode&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.java.bytecode&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.jimple.parser&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.callgraph&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n  &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n  &lt;artifactId&gt;sootup.analysis&lt;/artifactId&gt;\n  &lt;version&gt;1.2.0&lt;/version&gt;\n &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"installation/#gradle","title":"Gradle","text":"<p>Add the following dependency in the <code>build.gradle</code> file of your project to include all SootUp modules into your project.</p> <pre><code>repositories {\n    mavenCentral()\n    google()\n    maven {\n        url \"https://jitpack.io\"\n    }\n}\n\ncompile \"org.soot-oss:sootup.core:1.2.0\"\ncompile \"org.soot-oss:sootup.java.core1.2.0\"\ncompile \"org.soot-oss:sootup.java.sourcecode1.2.0\"\ncompile \"org.soot-oss:sootup.java.bytecode1.2.0\"\ncompile \"org.soot-oss:sootup.jimple.parser1.2.0\"\ncompile \"org.soot-oss:sootup.callgraph1.2.0\"\ncompile \"org.soot-oss:sootup.analysis1.2.0\"\n</code></pre>"},{"location":"installation/#building-from-source","title":"Building from Source","text":"<p>Build from source if you'd like to get the most recent changes. You can download the project as a zip file, or clone it using your favorite git client app or the command line:</p> <pre><code>git clone https://github.com/secure-software-engineering/SootUp.git\n</code></pre> <p>SootUp is a maven project. You can import it into your favorite IDE as a maven project. Run maven clean and install tasks using your IDE's maven plugin to set up the project.</p> <p>Alternatively, you can execute the following command in the project directory:</p> <pre><code>mvn install\n</code></pre> <p>Or if you want to skip tests while building:</p> <pre><code>mvn -Dskiptests install\n</code></pre>"},{"location":"jimple/","title":"Jimple","text":"<p>What is Jimple? Jimple is the intermediate representation IR of Soot, and thus SootUp. Soot's intention is to provide a simplified way to analyze JVM bytecode. JVM bytecode is stack-based, which makes it difficult for program analysis. Java source code, on the other hand, is also not quite suitable for program analysis, due to its nested structures. Therefore, Jimple aims to bring the best of both worlds, a non-stack-based and flat (non-nested) representation. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable.</p> <p>Info</p> <p>To learn more about jimple, refer to the thesis by Raja Vallee-Rai.</p> <p>It might help to visualize how the Jimple version of a Java code looks like. Have a look at the following example on the <code>HelloWorld</code> class.</p> JimpleJavaByte Code <pre><code>public class HelloWorld extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    HelloWorld r0;\n    r0 := @this: HelloWorld;\n    specialinvoke r0.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public static void main(java.lang.String[])\n  {\n    java.lang.String[] r0;\n    java.io.PrintStream r1;\n\n    r0 := @parameter0: java.lang.String[];\n    r1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke r1.&lt;java.io.PrintStream: \n    void println(java.lang.String)&gt;(\"Hello world!\");\n    return;\n  }\n}\n</code></pre> <pre><code>public class HelloWorld {\n\n  public HelloWorld() {\n\n  }\n\n  public static void main(String[] var0) {\n    System.out.println(\"Hello World!\");\n  }\n\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class analysis/HelloWorld {\n\n// compiled from: HelloWorld.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 4 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 6 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Lanalysis/HelloWorld; L0 L2 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static main([Ljava/lang/String;)V\n  L0\n    LINENUMBER 9 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Hello World!\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 10 L1\n    RETURN\n  L2\n    LOCALVARIABLE var0 [Ljava/lang/String; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#jimple-grammar-structure","title":"Jimple Grammar Structure","text":"<p>Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.)</p>"},{"location":"jimple/#class-or-interface","title":"Class (or Interface)","text":"<p>A class consists of Fields and Methods. It is referenced by its ClassType.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n}\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#field","title":"Field","text":"<p>A Field is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: double pi&gt; = 3.14;\n    return;\n  }\n}\n/*\n  \"this.&lt;target.exercise1.DemoClass: double pi&gt;\" is JInstanceFieldRef\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private final double pi = 3.14;\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x12\nprivate final D pi = 3.14\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    LDC 3.14\n    PUTFIELD target/exercise1/DemoClass.pi : D\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#method-and-the-body","title":"Method and the Body","text":"<p>The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature and contains a StmtGraph that models the sequence of single instructions/statements (Stmts).  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    virtualinvoke this.&lt;target.exercise1.DemoClass: \n    void demoMethod()&gt;();\n    return;\n  }\n\n  public void demoMethod()\n  {\n    java.io.PrintStream $stack1;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n    virtualinvoke $stack1.&lt;java.io.PrintStream: \n    void println(java.lang.String)&gt;(\"Inside method.\");\n    return;\n  }\n}\n/*\n  \"&lt;target.exercise1.DemoClass: void demoMethod()&gt;\" \n        and \"&lt;target.exercise1.DemoClass: void &lt;init&gt;()&gt;\" \n        are instances of SootMethod \n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  DemoClass(){\n    demoMethod();\n  }\n  public void demoMethod(){\n    System.out.println(\"Inside method.\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x0\n&lt;init&gt;()V\n  L0\n    LINENUMBER 5 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 6 L1\n    ALOAD 0\n    INVOKEVIRTUAL target/exercise1/DemoClass.demoMethod ()V\n  L2\n    LINENUMBER 7 L2\n    RETURN\n  L3\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L3 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic demoMethod()V\n  L0\n    LINENUMBER 10 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Inside method.\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 11 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#signatures","title":"Signatures","text":"<p>Signatures are required for identifying or referencing things across a method, such as Classes, Interfaces, Methods or Fields.  Locals, on the other hand, do not need signatures, since they are referenced within method boundaries.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: double pi&gt; = 3.14;\n    return;\n  }\n\n  public void demoMethod()\n  {\n    java.io.PrintStream $stack3, $stack5;\n    java.lang.StringBuilder $stack4, $stack6, $stack7;\n    java.lang.String $stack8;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n    virtualinvoke $stack3.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"pi : 3.14\");\n    $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    $stack4 = new java.lang.StringBuilder;\n\n    specialinvoke $stack4.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();\n    $stack6 = virtualinvoke $stack4.&lt;java.lang.StringBuilder: \n      java.lang.StringBuilder append(java.lang.String)&gt;\n        (\"pi : \");\n    $stack7 = virtualinvoke $stack6.&lt;java.lang.StringBuilder: \n      java.lang.StringBuilder append(double)&gt;(3.1415);\n    $stack8 = virtualinvoke $stack7.&lt;java.lang.StringBuilder: \n      java.lang.String toString()&gt;();\n\n    virtualinvoke $stack5.&lt;java.io.PrintStream:     \n      void println(java.lang.String)&gt;($stack8);\n    return;\n  }\n}\n/*\n  For JInstanceFieldRef \"this.&lt;target.exercise1.DemoClass: double pi&gt;\" \n    signature is &lt;target.exercise1.DemoClass: double pi&gt;\n  Similarly, we have other signatures like \n    &lt;java.lang.Object: void &lt;init&gt;()&gt;, \n    &lt;java.io.PrintStream: void println(java.lang.String)&gt; \n    and so on. \n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private final double pi = 3.14;\n\n  public void demoMethod(){\n    double localPi = 3.1415;\n    System.out.println(\"pi : \" + pi);\n    System.out.println(\"pi : \" + localPi);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x12\nprivate final D pi = 3.14\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    LDC 3.14\n    PUTFIELD target/exercise1/DemoClass.pi : D\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic demoMethod()V\n  L0\n    LINENUMBER 6 L0\n    LDC 3.1415\n    DSTORE 1\n  L1\n    LINENUMBER 7 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"pi : 3.14\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L2\n    LINENUMBER 8 L2\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    NEW java/lang/StringBuilder\n    DUP\n    INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n    LDC \"pi : \"\n      INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)\n        Ljava/lang/StringBuilder;\n    DLOAD 1\n    INVOKEVIRTUAL java/lang/StringBuilder.append (D)Ljava/lang/StringBuilder;\n    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 9 L3\n    RETURN\n  L4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0\n    LOCALVARIABLE localPi D L1 L4 1\n    MAXSTACK = 4\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple/#trap","title":"Trap","text":"<p>A Trap is a mechanism to model exceptional flow.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void divideExample(int, int)\n  {\n    int x, y, $stack4;\n    java.io.PrintStream $stack5, $stack7;\n    java.lang.Exception $stack6;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n    y := @parameter1: int;\n\n   label1:\n      $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack4 = x / y;\n      virtualinvoke $stack5.&lt;java.io.PrintStream: void println(int)&gt;($stack4);\n\n   label2:\n      goto label4;\n\n   label3:\n      $stack6 := @caughtexception;\n      $stack7 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack7.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Exception caught\");\n\n   label4:\n      return;\n\n      catch java.lang.Exception from label1 to label2 with label3;\n  }\n}\n/*\n  By calling getTraps() method, we can get the Traip chain.\n  For the above jimple code, we have the below trap:\n  Trap :\n  begin  : $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;\n  end    : goto [?= return]\n  handler: $stack6 := @caughtexception\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void divideExample(int x, int y){\n    try {\n      System.out.println(x / y);\n    }catch (Exception e){\n      System.out.println(\"Exception caught\");\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n    L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic divideExample(II)V\n  TRYCATCHBLOCK L0 L1 L2 java/lang/Exception\n  L0\n    LINENUMBER 6 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    ILOAD 2\n    IDIV\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L1\n    LINENUMBER 9 L1\n    GOTO L3\n  L2\n    LINENUMBER 7 L2\n    FRAME SAME1 java/lang/Exception\n    ASTORE 3\n  L4\n    LINENUMBER 8 L4\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Exception caught\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 10 L3\n    FRAME SAME\n    RETURN\n  L5\n    LOCALVARIABLE e Ljava/lang/Exception; L4 L3 3\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE x I L0 L5 1\n    LOCALVARIABLE y I L0 L5 2\n    MAXSTACK = 3\n    MAXLOCALS = 4\n}\n</code></pre>"},{"location":"jimple/#stmt","title":"Stmt","text":"<p>The main piece of Jimple is a Statement (Stmt). Stmts represent that can be executed by the JVM.</p>"},{"location":"jimple/#branching-statements","title":"Branching Statements","text":"<p>A BranchingStmt's job is to model the flow between Stmts.</p>"},{"location":"jimple/#jgotostmt","title":"JGotoStmt","text":"<p>for unconditional flow.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n  public static void sampleMethod()\n  {\n    int i;\n    i = 0;\n\n    label1:\n      if i &gt;= 5 goto label3;\n      if i != 3 goto label2;\n      goto label3;\n\n    label2:\n      i = i + 1;\n      goto label1;\n\n    label3:\n      return;\n  }\n}\n/*\n  Here for statements \"goto label3;\" and \"goto label1;\", \n  we have two instances of JGotoStmt : \n    \"goto[?=return]\" and \"goto[?=(branch)]\".\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public static void sampleMethod(){\n    label1:\n    for (int i = 0; i &lt; 5; i++){\n      if(i == 3){\n        break label1;\n      }\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static sampleMethod()V\n  L0\n    LINENUMBER 6 L0\n    ICONST_0\n    ISTORE 0\n  L1\n    FRAME APPEND [I]\n    ILOAD 0\n    ICONST_5\n    IF_ICMPGE L2\n  L3\n    LINENUMBER 7 L3\n    ILOAD 0\n    ICONST_3\n    IF_ICMPNE L4\n  L5\n    LINENUMBER 8 L5\n    GOTO L2\n  L4\n    LINENUMBER 6 L4\n    FRAME SAME\n    IINC 0 1\n    GOTO L1\n  L2\n    LINENUMBER 11 L2\n    FRAME CHOP 1\n    RETURN\n    LOCALVARIABLE i I L1 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#jifstmt","title":"JIfStmt","text":"<p>for conditional flow depending on boolean Expression (AbstractConditionExpr) so they have two successor Stmt's.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n   public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public static void sampleMethod(int)\n  {\n    int x, $stack1;\n    java.io.PrintStream $stack2, $stack3;\n\n    x := @parameter0: int;\n\n    $stack1 = x % 2;\n    if $stack1 != 0 goto label1;\n\n    $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack3.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"Even\");\n    goto label2;\n\n    label1:\n      $stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack2.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Odd\");\n\n    label2:\n      return;\n  }\n}\n/*\n  For statement \"if $stack1 != 0 goto label1;\", \n  we have an instance of JIfStmt :\n    \"if $stack1 != 0 goto $stack2 \n        = &lt;java.lang.System:java.io.PrintStream out&gt;\".\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public static void sampleMethod(int x){\n    if(x % 2 == 0){\n      System.out.println(\"Even\");\n    }else{\n      System.out.println(\"Odd\");\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static sampleMethod(I)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 0\n    ICONST_2\n    IREM\n    IFNE L1\n  L2\n    LINENUMBER 6 L2\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Even\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n    GOTO L3\n  L1\n    LINENUMBER 8 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Odd\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 10 L3\n    FRAME SAME\n    RETURN\n  L4\n    LOCALVARIABLE x I L0 L4 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#jswitchstmt","title":"JSwitchStmt","text":"<p>for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. </p> <p>All other Stmts are not manipulating the flow, which means they have a single successor Stmt as long as they are not exiting the flow inside a method.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void switchExample(int)\n  {\n    int x;\n    java.io.PrintStream $stack2, $stack3, $stack4;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    lookupswitch(x)\n    {\n      case 1: goto label1;\n      case 2: goto label2;\n      default: goto label3;\n    };\n\n    label1:\n      $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack3.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input 1\");\n      goto label4;\n\n    label2:\n      $stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack2.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input 2\");\n      goto label4;\n\n    label3:\n      $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack4.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input more than 2\");\n\n    label4:\n      return;\n  }\n}\n/*\n  Here for below statement:\n    lookupswitch(x)\n      {\n        case 1: goto label1;\n        case 2: goto label2;\n        default: goto label3;\n      };\n\n  we have an instance of JLookupSwitchStmt :\n    lookupswitch(x) \n      {     \n        case 1: goto $stack3 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;;     \n        case 2: goto $stack2 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;;     \n        default: goto $stack4 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;; \n      }\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void switchExample(int x){\n    switch (x){\n      case 1:\n        System.out.println(\"Input 1\");\n        break;\n\n      case 2:\n        System.out.println(\"Input 2\");\n        break;\n\n      default:\n        System.out.println(\"Input more than 2\");\n        break;\n\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic switchExample(I)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 1\n    LOOKUPSWITCH\n    1: L1\n    2: L2\n    default: L3\n  L1\n    LINENUMBER 7 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input 1\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L4\n    LINENUMBER 8 L4\n    GOTO L5\n  L2\n    LINENUMBER 11 L2\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input 2\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L6\n    LINENUMBER 12 L6\n    GOTO L5\n  L3\n    LINENUMBER 15 L3\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input more than 2\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L5\n    LINENUMBER 19 L5\n    FRAME SAME\n    RETURN\n  L7\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L7 0\n    LOCALVARIABLE x I L0 L7 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple/#jreturnstmt-jreturnvoidstmt","title":"JReturnStmt &amp; JReturnVoidStmt","text":"<p>They end the execution/flow inside the current method and return (a value) to its caller.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public int increment(int)\n  {\n    int x, $stack2;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    $stack2 = x + 1;\n    return $stack2;\n  }\n\n  public void print()\n  {\n    java.io.PrintStream $stack1;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack1.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"Inside method print\");\n    return;\n  }\n}\n/*\n  \"return $stack2\" is JReturnStmt.\n  \"return\" is JReturnVoidStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public int increment(int x){\n    return x + 1;\n  }\n  public void print(){\n    System.out.println(\"Inside method print\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic increment(I)I\n  L0\n    LINENUMBER 5 L0\n    ILOAD 1\n    ICONST_1\n    IADD\n    IRETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE x I L0 L1 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n\n// access flags 0x1\npublic print()V\n  L0\n    LINENUMBER 8 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Inside method print\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 9 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#jthrowstmt","title":"JThrowStmt","text":"<p>Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void divideExample(int, int)\n  {\n    int y, x, $stack6;\n    java.lang.StringBuilder $stack3, $stack5, $stack7;\n    java.io.PrintStream $stack4;\n    java.lang.String $stack8;\n    java.lang.RuntimeException $stack9;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n    y := @parameter1: int;\n\n    if y != 0 goto label1;\n\n    $stack9 = new java.lang.RuntimeException;\n    specialinvoke $stack9.&lt;java.lang.RuntimeException: \n      void &lt;init&gt;(java.lang.String)&gt;(\"Divide by zero error\");\n    throw $stack9;\n\n    label1:\n      $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack3 = new java.lang.StringBuilder;\n      specialinvoke $stack3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();\n\n      $stack5 = virtualinvoke $stack3.&lt;java.lang.StringBuilder: \n        java.lang.StringBuilder append(java.lang.String)&gt;(\"Divide result : \");\n      $stack6 = x / y;\n      $stack7 = virtualinvoke $stack5.&lt;java.lang.StringBuilder: \n        java.lang.StringBuilder append(int)&gt;($stack6);\n      $stack8 = virtualinvoke $stack7.&lt;java.lang.StringBuilder: \n        java.lang.String toString()&gt;();\n\n      virtualinvoke $stack4.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;($stack8);\n      return;\n  }\n}\n/*\n  \"throw $stack9\" is JThrowStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void divideExample(int x, int y){\n    if(y == 0){\n      throw new RuntimeException(\"Divide by zero error\");\n    }\n    System.out.println(\"Divide result : \" + x / y);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic divideExample(II)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 2\n    IFNE L1\n  L2\n    LINENUMBER 6 L2\n    NEW java/lang/RuntimeException\n    DUP\n    LDC \"Divide by zero error\"\n    INVOKESPECIAL java/lang/RuntimeException.&lt;init&gt; \n      (Ljava/lang/String;)V\n    ATHROW\n  L1\n    LINENUMBER 8 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    NEW java/lang/StringBuilder\n    DUP\n    INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n    LDC \"Divide result : \"\n    INVOKEVIRTUAL java/lang/StringBuilder.append \n      (Ljava/lang/String;)Ljava/lang/StringBuilder;\n    ILOAD 1\n    ILOAD 2\n    IDIV\n    INVOKEVIRTUAL java/lang/StringBuilder.append \n      (I)Ljava/lang/StringBuilder;\n    INVOKEVIRTUAL java/lang/StringBuilder.toString \n      ()Ljava/lang/String;\n    INVOKEVIRTUAL java/io/PrintStream.println \n      (Ljava/lang/String;)V\n  L3\n    LINENUMBER 9 L3\n    RETURN\n  L4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0\n    LOCALVARIABLE x I L0 L4 1\n    LOCALVARIABLE y I L0 L4 2\n    MAXSTACK = 4\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple/#jinvokestmt","title":"JInvokeStmt","text":"<p>transfers the control flow to another method until the called method returns.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void print(int)\n  {\n    target.exercise1.DemoClass this;\n    int x, a;\n    java.io.PrintStream $stack4, $stack6;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    a = virtualinvoke this.&lt;target.exercise1.DemoClass: \n      int increment(int)&gt;(x);\n    $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack4.&lt;java.io.PrintStream: \n      void println(int)&gt;(a);\n\n    a = virtualinvoke this.&lt;target.exercise1.DemoClass: \n      int increment(int)&gt;(a);\n    $stack6 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack6.&lt;java.io.PrintStream: \n      void println(int)&gt;(a);\n\n    return;\n  }\n\n  public int increment(int)\n  {\n    int x, $stack2;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    $stack2 = x + 1;\n    return $stack2;\n  }\n}\n/*\n  \"specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;()\", \n  \"virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(x)\", \n  \"virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(a)\" \n    are JInvokeStmts.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void print(int x){\n    int a = increment(x);\n    System.out.println(a);\n    a = increment(a);\n    System.out.println(a);\n  }\n  public int increment(int x){\n    return x + 1;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic print(I)V\n  L0\n    LINENUMBER 5 L0\n    ALOAD 0\n    ILOAD 1\n    INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I\n    ISTORE 2\n  L1\n    LINENUMBER 6 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L2\n    LINENUMBER 7 L2\n    ALOAD 0\n    ILOAD 2\n    INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I\n    ISTORE 2\n  L3\n    LINENUMBER 8 L3\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L4\n    LINENUMBER 9 L4\n    RETURN\n  L5\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE x I L0 L5 1\n    LOCALVARIABLE a I L1 L5 2\n    MAXSTACK = 2\n    MAXLOCALS = 3\n\n// access flags 0x1\npublic increment(I)I\n  L0\n    LINENUMBER 11 L0\n    ILOAD 1\n    ICONST_1\n    IADD\n    IRETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE x I L0 L1 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple/#jassignstmt","title":"JAssignStmt","text":"<p>assigns a Value from the right hand-side to the left hand-side. Left hand-side of an assignment can be a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. Right hand-side of an assignment can be an expression (Expr), a Local, a FieldRef or a Constant.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = 0;\n    return;\n  }\n\n  public int updateCounter()\n  {\n    target.exercise1.DemoClass this;\n    int $stack1, $stack2, $stack3;\n\n    this := @this: target.exercise1.DemoClass;\n\n    $stack1 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n    $stack2 = $stack1 + 1;\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack2;\n    $stack3 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n\n    return $stack3;\n  }\n}\n/*\n  \"this.&lt;target.exercise1.DemoClass: int counter&gt; = 0\", \n  \"$stack1 = this.&lt;target.exercise1.DemoClass: int counter&gt;\",\n  \"$stack2 = $stack1 + 1\"\n  \"this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack2\"\n  \"$stack3 = this.&lt;target.exercise1.DemoClass: int counter&gt;\"\n    are JAssignStmts.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter = 0;\n  public int updateCounter(){\n    counter = counter + 1;\n    return counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    ICONST_0\n    PUTFIELD target/exercise1/DemoClass.counter : I\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic updateCounter()I\n  L0\n    LINENUMBER 6 L0\n    ALOAD 0\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    ICONST_1\n    IADD\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L1\n    LINENUMBER 7 L1\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    IRETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#jidentitystmt","title":"JIdentityStmt","text":"<p>is semantically like the JAssignStmt and handles assignments of IdentityRef's to make implicit assignments explicit into the StmtGraph.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void DemoClass(int)\n  {\n    target.exercise1.DemoClass this;\n    int counter;\n\n    this := @this: target.exercise1.DemoClass;\n    counter := @parameter0: int;\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = counter;\n    return;\n  }\n}\n/*\n  \"this := @this: target.exercise1.DemoClass\" and \n    \"counter := @parameter0: int\" are JIdentityStmts\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter;\n  public void DemoClass(int counter){\n    this.counter = counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic DemoClass(I)V\n  L0\n    LINENUMBER 6 L0\n    ALOAD 0\n    ILOAD 1\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L1\n    LINENUMBER 7 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    LOCALVARIABLE counter I L0 L2 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple/#jentermonitorstmt-jexitmonitorstmt","title":"JEnterMonitorStmt &amp; JExitMonitorStmt","text":"<p>marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt.  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = 0;\n    return;\n  }\n\n  public int updateCounter()\n  {\n    target.exercise1.DemoClass this;\n    int $stack4, $stack5, $stack7;\n    java.lang.Throwable $stack8;\n\n    this := @this: target.exercise1.DemoClass;\n\n    entermonitor this;\n\n    label1:\n      $stack4 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n      $stack5 = $stack4 + 1;\n      this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack5;\n\n      exitmonitor this;\n\n    label2:\n      goto label5;\n\n    label3:\n      $stack8 := @caughtexception;\n\n      exitmonitor this;\n\n    label4:\n      throw $stack8;\n\n    label5:\n      $stack7 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n      return $stack7;\n\n      catch java.lang.Throwable from label1 to label2 with label3;\n      catch java.lang.Throwable from label3 to label4 with label3;\n  }\n}\n/*\n  \"entermonitor this\" is JEnterMonitorStmt.\n  \"exitmonitor this\" is JExitMonitorStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter = 0;\n  public int updateCounter(){\n    synchronized (this) {\n      counter = counter + 1;\n    }\n    return counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    ICONST_0\n    PUTFIELD target/exercise1/DemoClass.counter : I\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic updateCounter()I\n    TRYCATCHBLOCK L0 L1 L2 null\n    TRYCATCHBLOCK L2 L3 L2 null\n  L4\n    LINENUMBER 6 L4\n    ALOAD 0\n    DUP\n    ASTORE 1\n    MONITORENTER\n  L0\n    LINENUMBER 7 L0\n    ALOAD 0\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    ICONST_1\n    IADD\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L5\n    LINENUMBER 8 L5\n    ALOAD 1\n    MONITOREXIT\n  L1\n    GOTO L6\n  L2\n    FRAME FULL [target/exercise1/DemoClass java/lang/Object] \n      [java/lang/Throwable]\n    ASTORE 2\n    ALOAD 1\n    MONITOREXIT\n  L3\n    ALOAD 2\n    ATHROW\n  L6\n    LINENUMBER 9 L6\n    FRAME CHOP 1\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    IRETURN\n  L7\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L4 L7 0\n    MAXSTACK = 3\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple/#jretstmt","title":"JRetStmt","text":""},{"location":"jimple/#jbreakpointstmt","title":"JBreakpointStmt","text":"<p>models a Breakpoint set by a Debugger (usually not relevant for static analyses)</p>"},{"location":"jimple/#immediate","title":"Immediate","text":"<p>An Immediate has a given Type and consists of a Local (\"a Variable\", \"Something that contains a Value\") or a Constant (\"Something that is a Value\").</p>"},{"location":"jimple/#type","title":"Type","text":"<p>VoidType  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n  return;\n  }\n\n  public void voidMethod()\n  {\n  java.io.PrintStream $stack1;\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n  virtualinvoke $stack1.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"In voidMethod().\");\n  return;\n  }\n}\n/*\n  For the SootMethod - &lt;target.exercise1.DemoClass: void voidMethod()&gt;, \n    returnType is instance of VoidType.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void voidMethod(){\n  System.out.println(\"In voidMethod().\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic voidMethod()V\n  L0\n    LINENUMBER 5 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"In voidMethod().\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 6 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#primarytype","title":"PrimaryType","text":"<p>BooleanType, ByteType, CharType, ShortType, IntType, LongType, DoubleType, FloatType  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n      target.exercise1.DemoClass this;\n      this := @this: target.exercise1.DemoClass;\n      specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n      return;\n  }\n\n\n  public void display()\n  {\n      java.io.PrintStream $stack11, $stack13, $stack15, \n        $stack17, $stack19, $stack21, $stack23, $stack25;\n      int $stack12, $stack14, $stack16, $stack18;\n      long $stack20;\n      double $stack22;\n      float $stack24;\n      target.exercise1.DemoClass this;\n      boolean $stack26;\n\n      this := @this: target.exercise1.DemoClass;\n\n      $stack11 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n      goto label1;\n\n   label1:\n      $stack26 = 0;\n      virtualinvoke $stack11.&lt;java.io.PrintStream: \n        void println(boolean)&gt;($stack26);\n\n      $stack13 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack12 = 127 - 1;\n      virtualinvoke $stack13.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack12);\n\n      $stack15 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack14 = 97 + 1;\n      virtualinvoke $stack15.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack14);\n\n      $stack17 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack16 = 1123 + 1;\n      virtualinvoke $stack17.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack16);\n\n      $stack19 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack18 = 123456 + 1;\n      virtualinvoke $stack19.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack18);\n\n      $stack21 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack20 = 10L + 1L;\n      virtualinvoke $stack21.&lt;java.io.PrintStream: \n        void println(long)&gt;($stack20);\n\n      $stack23 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack22 = 10.1 + 1.0;\n      virtualinvoke $stack23.&lt;java.io.PrintStream: \n        void println(double)&gt;($stack22);\n\n      $stack25 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack24 = 10.1F + 1.0F;\n      virtualinvoke $stack25.&lt;java.io.PrintStream: \n        void println(float)&gt;($stack24);\n\n      return;\n  }\n}\n/*\n  The JimpleLocal $stack12, $stack14, $stack16, $stack18 are of IntType. \n  Similarly, $stack20 is of LongType, $stack22 is of DoubleType and so on.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void display(){\n    boolean varBoolean = true;\n    byte varByte = 127;\n    char varChar = 'a';\n    short varShort = 1123;\n    int varInt = 123456;\n    long varLong = 10L;\n    double varDouble = 10.10;\n    float varFloat = 10.10f;\n\n    System.out.println(!varBoolean);\n    System.out.println(varByte-1);\n    System.out.println(varChar+1);\n    System.out.println(varShort+1);\n    System.out.println(varInt+1);\n    System.out.println(varLong+1);\n    System.out.println(varDouble+1);\n    System.out.println(varFloat+1);\n\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic display()V\n  L0\n    LINENUMBER 5 L0\n    ICONST_1\n    ISTORE 1\n  L1\n    LINENUMBER 6 L1\n    BIPUSH 127\n    ISTORE 2\n  L2\n    LINENUMBER 7 L2\n    BIPUSH 97\n    ISTORE 3\n  L3\n    LINENUMBER 8 L3\n    SIPUSH 1123\n    ISTORE 4\n  L4\n    LINENUMBER 9 L4\n    LDC 123456\n    ISTORE 5\n  L5\n    LINENUMBER 10 L5\n    LDC 10\n    LSTORE 6\n  L6\n    LINENUMBER 11 L6\n    LDC 10.1\n    DSTORE 8\n  L7\n    LINENUMBER 12 L7\n    LDC 10.1\n    FSTORE 10\n  L8\n    LINENUMBER 14 L8\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    IFNE L9\n    ICONST_1\n    GOTO L10\n  L9\n    FRAME FULL [target/exercise1/DemoClass I I I I I J D F] \n      [java/io/PrintStream]\n    ICONST_0\n  L10\n    FRAME FULL [target/exercise1/DemoClass I I I I I J D F] \n      [java/io/PrintStream I]\n    INVOKEVIRTUAL java/io/PrintStream.println (Z)V\n  L11\n    LINENUMBER 15 L11\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    ICONST_1\n    ISUB\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L12\n    LINENUMBER 16 L12\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 3\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L13\n    LINENUMBER 17 L13\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 4\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L14\n    LINENUMBER 18 L14\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 5\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L15\n    LINENUMBER 19 L15\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LLOAD 6\n    LCONST_1\n    LADD\n    INVOKEVIRTUAL java/io/PrintStream.println (J)V\n  L16\n    LINENUMBER 20 L16\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    DLOAD 8\n    DCONST_1\n    DADD\n    INVOKEVIRTUAL java/io/PrintStream.println (D)V\n  L17\n    LINENUMBER 21 L17\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    FLOAD 10\n    FCONST_1\n    FADD\n    INVOKEVIRTUAL java/io/PrintStream.println (F)V\n  L18\n    LINENUMBER 23 L18\n    RETURN\n  L19\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L19 0\n    LOCALVARIABLE varBoolean Z L1 L19 1\n    LOCALVARIABLE varByte B L2 L19 2\n    LOCALVARIABLE varChar C L3 L19 3\n    LOCALVARIABLE varShort S L4 L19 4\n    LOCALVARIABLE varInt I L5 L19 5\n    LOCALVARIABLE varLong J L6 L19 6\n    LOCALVARIABLE varDouble D L7 L19 8\n    LOCALVARIABLE varFloat F L8 L19 10\n    MAXSTACK = 5\n    MAXLOCALS = 11\n}\n</code></pre>"},{"location":"jimple/#referencetype","title":"ReferenceType","text":"<p>ClassType,  ArrayType NullType  </p> JimpleJavaByte Code <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\npublic void &lt;init&gt;()\n  {\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n  return;\n  }\n\n  public target.exercise1.DemoClass getObject(target.exercise1.DemoClass)\n  {\n  target.exercise1.DemoClass obj, this;\n  this := @this: target.exercise1.DemoClass;\n  obj := @parameter0: target.exercise1.DemoClass;\n  return obj;\n  }\n\n  public void compute(boolean)\n  {\n  int[] b;\n  java.io.PrintStream $stack5, $stack6;\n  boolean check;\n  target.exercise1.DemoClass this;\n  int i;\n  null_type r0;\n  java.lang.NullPointerException soot0;\n  this := @this: target.exercise1.DemoClass;\n  check := @parameter0: boolean;\n  b = newarray (int)[5];\n  i = 0;\n\n  label1:\n    if i &gt;= 5 goto label3;\n      if check == 0 goto label2;\n      r0 = (null_type) i;\n      soot0 = new java.lang.NullPointerException;\n      specialinvoke soot0.&lt;java.lang.NullPointerException: \n        void &lt;init&gt;(java.lang.String)&gt;\n          (\"This statement would have triggered an Exception: a[i#1] = r0\");\n      throw soot0;\n\n  label2:\n  b[i] = i;\n      i = i + 1;\n      goto label1;\n\n  label3:\n      $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack5.&lt;java.io.PrintStream: \n        void println(java.lang.Object)&gt;(b);\n      $stack6 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack6.&lt;java.io.PrintStream: \n        void println(java.lang.Object)&gt;(null);\n      return;\n  }\n}\n/*\n  The JimpleLocal b is of ArrayType,\n    and JimpleLocal r0 is of NullType.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n\n  public DemoClass getObject(DemoClass obj){\n    return obj;\n  }\n\n  public void compute(boolean check){\n    int a[] = null;\n    int b[] = new int[5];\n    for (int i = 0; i &lt; 5; i++) {\n      if(check){\n        a[i] = i;\n      }\n        b[i] = i;\n    }\n    System.out.println(b);\n    System.out.println(a);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic getObject(Ltarget/exercise1/DemoClass;)Ltarget/exercise1/DemoClass;\n  L0\n    LINENUMBER 6 L0\n    ALOAD 1\n    ARETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE obj Ltarget/exercise1/DemoClass; L0 L1 1\n    MAXSTACK = 1\n    MAXLOCALS = 2\n\n// access flags 0x1\npublic compute(Z)V\n  L0\n    LINENUMBER 10 L0\n    ACONST_NULL\n    ASTORE 2\n  L1\n    LINENUMBER 11 L1\n    ICONST_5\n    NEWARRAY T_INT\n    ASTORE 3\n  L2\n    LINENUMBER 12 L2\n    ICONST_0\n    ISTORE 4\n  L3\n    FRAME APPEND [[I [I I]\n    ILOAD 4\n    ICONST_5\n    IF_ICMPGE L4\n  L5\n    LINENUMBER 13 L5\n    ILOAD 1\n    IFEQ L6\n  L7\n    LINENUMBER 14 L7\n    ALOAD 2\n    ILOAD 4\n    ILOAD 4\n    IASTORE\n  L6\n    LINENUMBER 16 L6\n    FRAME SAME\n    ALOAD 3\n    ILOAD 4\n    ILOAD 4\n    IASTORE\n  L8\n    LINENUMBER 12 L8\n    IINC 4 1\n    GOTO L3\n  L4\n    LINENUMBER 18 L4\n    FRAME CHOP 1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ALOAD 3\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V\n  L9\n    LINENUMBER 19 L9\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ALOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V\n  L10\n    LINENUMBER 20 L10\n    RETURN\n  L11\n    LOCALVARIABLE i I L3 L4 4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L11 0\n    LOCALVARIABLE check Z L0 L11 1\n    LOCALVARIABLE a [I L1 L11 2\n    LOCALVARIABLE b [I L2 L11 3\n    MAXSTACK = 3\n    MAXLOCALS = 5\n}\n</code></pre>"},{"location":"jimple/#local","title":"Local","text":"<p><code>jimple i0</code> A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt.  </p> JimpleJavaByte Code <p>```jimple public class target.exercise1.DemoClass extends java.lang.Object {   public void ()   {     target.exercise1.DemoClass this;     this := @this: target.exercise1.DemoClass;     specialinvoke this.()&gt;();     return;   } <p>public void compute()   {     java.io.PrintStream $stack2, $stack3;     target.exercise1.DemoClass this;     int local#2;</p> <pre><code>this := @this: target.exercise1.DemoClass;\n$stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\nvirtualinvoke $stack2.&lt;java.io.PrintStream: void println(int)&gt;(1);\n\nlocal#2 = this.&lt;target.exercise1.DemoClass: int global&gt;;\n$stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\nvirtualinvoke $stack3.&lt;java.io.PrintStream: void println(int)&gt;(local#2);\nreturn;\n</code></pre> <p>} } /*   $stack2, this, $stack3, local#2 are all JimpleLocal.</p> <p>\"this := @this: target.exercise1.DemoClass\" is JIdentityStmt</p> <p>\"$stack2 = \",      \"local#2 = this.\",        \"$stack3 = \"          are JAssignStmt <p>*/ ```</p> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n\n  private int global;\n\n  public void compute(){\n    int local;\n    local = 1;\n    System.out.println(local);\n    local = this.global;\n    System.out.println(local);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I global\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic compute()V\n  L0\n    LINENUMBER 9 L0\n    ICONST_1\n    ISTORE 1\n  L1\n    LINENUMBER 10 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L2\n    LINENUMBER 11 L2\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.global : I\n    ISTORE 1\n  L3\n    LINENUMBER 12 L3\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L4\n    LINENUMBER 14 L4\n    RETURN\n  L5\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE local I L1 L5 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple/#constant","title":"Constant","text":"<p>represents a value itself. don't confuse it with a variable/Local which has a immutable (i.e. final) attribute. </p> <p>There exists a constant entity for every Type - that way all value types can have a representation.</p>"},{"location":"jimple/#expr","title":"Expr","text":"<p>An expression is a language construct that returns a value. E.g. a binary operation such as addition.</p>"},{"location":"jimple/#ref","title":"Ref","text":""},{"location":"jimple/#jarrayref","title":"JArrayRef","text":"<p><code>jimple $arr[1]</code> referencing a position inside an array.</p>"},{"location":"jimple/#jfieldref-jstaticfieldref-jinstancefieldref","title":"JFieldRef (JStaticFieldRef &amp; JInstanceFieldRef)","text":"<p><code>jimple &lt;SomePackage.ExampleClass: fieldname&gt; // or r1.&lt;SomePackage.ExampleClass: fieldname&gt;</code> referencing a Field via its FieldSignature and if necessary (i.e. with JInstanceFieldRef) the corresponding Local instance that points to the object instance.</p>"},{"location":"jimple/#identityref","title":"IdentityRef","text":"<p>The IdentityRef makes those implicit special value assignments explicit.</p>"},{"location":"jimple/#jthisref","title":"JThisRef","text":"<p><code>jimple @this: package.fruit.Banana</code> represents the this pointer of the current class.</p>"},{"location":"jimple/#jcaughtexceptionref","title":"JCaughtExceptionRef","text":"<p><code>jimple @caughtexception</code> represents the value of the thrown exception (caught by this exceptionhandler).</p>"},{"location":"jimple/#jparameterref","title":"JParameterRef","text":"<p><code>jimple i0 := @parameter0 i1 := @parameter1</code> represents a parameter of a method, identified by its index.</p>"},{"location":"tools/","title":"Who uses SootUp","text":"<ul> <li>JimpleLsp</li> <li>API_ASSIST</li> <li>Maybe there is more to find via Github Network Dependents - have a look at the individual modules. </li> <li>Your tool is not on this list? Create a PR :-)</li> </ul>"},{"location":"whatsnew/","title":"What's new in SootUp?","text":""},{"location":"whatsnew/#library-by-default","title":"Library by default","text":"<p>While Soot is a library and a stand-alone command-line application. SootUp, on the other hand, is designed to be a core library. It assumes that it is embedded in a client application that owns the thread of control. It can be extended with a command-line interface, included in other software projects as a library, or integrated into IDEs with JimpleLSP.</p>"},{"location":"whatsnew/#modular-architecture","title":"Modular Architecture","text":"<p>SootUp has a modular architecture, which enables its clients to include only the necessary functionality to their applications.</p> <ul> <li>core module contains the core building blocks such as the jimple IR, control flow graphs, and frontend interfaces. The rest of the modules build on the core module.</li> <li>java.core module contains parts that are essential for analyzing Java code.</li> <li>java.bytecode module contains the functionality that is necessary for taking as input java bytecode.</li> <li>java.sourcecode module contains the functionality that is necessary for taking as input java source code.  Beware: The sourcecodefrontend is currently unable to handle inputs with exceptions (try/catch/finally)! </li> <li>callgraph module contains implementations of common call graph construction algorithms such as CHA, RTA. A reimplementation of Spark pointer analysis framework is in progress.</li> <li>jimple.parser module contains the functionalty that is necessary for taking as input .jimple files.</li> <li>analysis module enables performing interprocedural dataflow analyses.</li> </ul>"},{"location":"whatsnew/#no-more-singletons","title":"No More Singletons","text":"<p>Singletons offer a single view of a single program version, which makes it impossible to analyze multiple programs or multiple versions of the same program. SootUp does not make use of singletons such the <code>Scene</code> class in the old Soot any more. It enables analyzing multiple programs simultaneously.</p>"},{"location":"whatsnew/#new-source-code-frontend","title":"New Source Code Frontend","text":"<p>Soot's JastAdd-based java frontend is not maintained anymore. In SootUp, we use WALA's well-maintained source code frontend, which will not only allow Soot to analyze Java source code, but also JavaScript and Python.</p>"},{"location":"whatsnew/#immutable-by-design","title":"Immutable by Design","text":"<p>SootUp has been designed with the goal of immutability in mind. This makes sharing objects between several entities easier, because there is no need to worry about unintended changes to other entities.</p>"},{"location":"whatsnew/#withers-instead-of-setters","title":"Withers instead of Setters","text":"<p>Due to the goal of immutability, many classes do not have setters anymore. For example, a <code>Body</code> does not have a method <code>setStmts(List&lt;Stmt&gt; stmts)</code>. Instead, a method called <code>withStmts(List&lt;Stmt&gt; stmts)</code> has been added. This does not modify the original instance, but returns a copy of the Body but with the provided <code>stmts</code> in its instance. This concept of so-called <code>with</code>-ers can be found all throughout SootUp.</p> <p>A simplified example</p> <pre><code>class Body {\n  final List&lt;Stmt&gt; stmts;\n  final List&lt;Local&gt; locals;\n\n  Body(List&lt;Stmt&gt; stmts, List&lt;Local&gt; locals) {\n    this.stmts = stmts;\n    this.locals = locals;\n  }  \n\n  Body withStmts(List&lt;Stmt&gt; stmts) { return new Body(stmts, this.locals); }\n  Body withLocals(List&lt;Local&gt; locals) { return new Body(this.stmts, locals); }\n}\n</code></pre>"},{"location":"whatsnew/#intermediate-representation","title":"Intermediate Representation","text":"<p>Jimple is the only intermediate representation (IR) in SootUp. We modified it slightly to be able to accommodate different programming languages in the future.</p>"},{"location":"write_analyses/","title":"Writing Analyses","text":"<pre><code>// TODO improve tutorial!\n</code></pre> <p>If you wish to implement an interprocedural data-flow analysis via the IFDS or IDE Framework please have a look at the test cases in the sootup.analysis submodule.</p>"}]}